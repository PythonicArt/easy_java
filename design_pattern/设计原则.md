1. Encapsulate what varies.

对于一个操作fun()， 不同的实例是否需要有不同的实现方式或是表现形式。 

某些实例需要相同的实现方式， 某些子类需要有自己的实现方式， 有些自己不应该有该操作。

如果是， 则不适合在父类中声明该方法，再由子类重载该方法的实现方式。

理由：
1. 有些子类不能有该操作， 继承会使子类拥有。
2. 如果实现方式由n个版本，则只有一种子类实现了代码复用， 其他种类的子类需要重写重复代码。

解决方式：
1. 新增一层继承关系。 
    superClass
        subClassA, subClassB, subClassC
    
    superClass无该操作的方法， 三个子类分别实现操作的不同版本， 让具有特殊版本操作的子类去继承对应的subClass
    如果子类不需要该操作， 可以直接继承superClass

2. 将方法抽出， 写成接口。需要该方法的类实现该接口

2. Favor composition over inheritance.

代码重用的两种简单地方式： 组合与继承。has-a vs is-a的问题。

我需要某种已经实现的功能， 除了自己再造一遍轮子， 还有以下两种方式
1. 组合的方式： 用一个已经实现该功能的对象实例作为自己的成员， 每次需要该方法， 用这个成员去执行。
2. 继承一个已经实现该功能的对象， 从而我也有了该功能。

继承的特性同时带来了不好的地方， 就是我在获得方法fun()时， 自己会额外的获得其他方法， 这些是我不需要的。
再者， java只允许单继承， 如果我本来就是其他类的子类或者我想拥有更多其他类的方法， 就再也无法选择继承的方式。

3. Program to interfaces, not implementations.
方法实现代码重用有两个基本的方式， 一个是通过继承而不重载父类的方法， 另一个是通过组合一个接口实例对象。

第二种优势明显， 也是组合的优势所在。第一个将实现和类已经绑定在了一起， 任何时候只能有一个版本的实现。 当修改方法的操作时， 所有子类实例都受到影响。
第二个可以动态调整， 只需引用另一个接口实例对象即可。当修改方法的操作时， 只有组合该实例的类受到影响。


前三点其实说的是一件事情， 对于有变化的操作， 采用接口的方式实现， 不要将实现的代码写在类中。 类中只保留不变的操作。

java中， 多态有两种基本的实现方式， 一种是通过继承重载方法，父类实例对象可以引用子类实例。 另一种是通过实现接口， 接口对象可以引用实现类的实例。


4. Strive for loosely coupled designs between objects that interact