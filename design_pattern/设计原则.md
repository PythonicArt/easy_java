1. Encapsulate what varies.

代码重用的好处
1. 减少重复代码的维护。 一个操作一份代码， 如果有多份， 必须保证其一致。 如果有修改， 则每一处都要修改。 这是很难维护的。 

对于一个操作fun()， 不同的实例是否需要有不同的实现方式或是表现形式。 

某些实例需要相同的实现方式， 某些子类需要有自己的实现方式， 有些自己不应该有该操作。

如果是， 则不适合在父类中声明该方法，再由子类重载该方法的实现方式。

理由：
1. 有些子类不能有该操作， 继承会使子类拥有。
2. 如果实现方式由n个版本，则只有一种子类实现了代码复用， 其他种类的子类需要重写重复代码。

解决方式：
1. 新增一层继承关系。 
    superClass
        subClassA, subClassB, subClassC
    
    superClass无该操作的方法， 三个子类分别实现操作的不同版本， 让具有特殊版本操作的子类去继承对应的subClass
    如果子类不需要该操作， 可以直接继承superClass

2. 将方法抽出， 写成接口。需要该方法的类实现该接口

2. Favor composition over inheritance.

代码重用的两种简单地方式： 组合与继承。has-a vs is-a的问题。

我需要某种已经实现的功能， 除了自己再造一遍轮子， 还有以下两种方式
1. 组合的方式： 用一个已经实现该功能的对象实例作为自己的成员， 每次需要该方法， 用这个成员去执行。
2. 继承一个已经实现该功能的对象， 从而我也有了该功能。

继承的特性同时带来了不好的地方， 就是我在获得方法fun()时， 自己会额外的获得其他方法， 这些是我不需要的。
再者， java只允许单继承， 如果我本来就是其他类的子类或者我想拥有更多其他类的方法， 就再也无法选择继承的方式。

在基类中， 对于有变化的操作， 采用接口的方式实现， 不要将实现的代码写在类中。 类中只保留不变的操作。

3. Program to interfaces, not implementations.
方法实现代码重用有两个基本的方式， 一个是通过继承而不重载父类的方法， 另一个是通过组合一个接口实例对象。

第二种优势明显， 也是组合的优势所在。第一个将实现和类已经绑定在了一起， 任何时候只能有一个版本的实现。 当修改方法的操作时， 所有子类实例都受到影响。
第二个可以动态调整， 只需引用另一个接口实例对象即可。当修改方法的操作时， 只有组合该实例的类受到影响。

java中， 多态有两种基本的实现方式， 一种是通过继承重载方法，父类实例对象可以引用子类实例。 另一种是通过实现接口， 接口对象可以引用实现类的实例。


4. Strive for loosely coupled designs between objects that interact


5. Classess should be open for extension but closed for modification.


6. Depend upon abstractions. Do not depend upon concrete classes.
依赖抽象的接口， 而不是具体的类。 工厂模式是一个很好的案例， 对于使用方， 尽可能地减少new Class的使用， 而是通过工厂模式去创建实例。
把 new Class放在实体的提供方。

高层次的 实体 和低层次的实体 都需要依赖于 抽象。 如果一个实体对象A 引用了另一个实体对象B ， 则A是高层次的， B是低层次的。

A需要将创建方式抽象， 使用工厂方法来创建。
B也需要抽象，因为引用的B对象是可能 不断发生变化的， 将公共功能抽出， 供A使用。 也就是A引用的是一个父类的对象， 而通过创建方式指向一个具体的子类对象。 不再直接引用一个具体的子类。

对于使用方，
1. 不要使用 new 去引用一个具体的实例。要用工厂方法
2. 如果一个类的方法 会有多个变化的版本， 不要继承与一个具体的类。应该将变化的部分抽象成接口或是抽象类，再继承。 
3. 子类只对父类进行扩展和实现, 不要重载已经有具体实现的父类的方法， 和第2点类似。把变化的部分抽象， 再继承。
4. 父类只包含以下属性： 公共的属性， 抽象的公共方法， 只有单一版本的方法的实现。      


在编程中如何思考呢？

重点考虑 实际需求中同一种类型， 是否具有多种表现方式。 这是对需求的明确。 

比如java的字符串， 其方法的表现方式是没有变化的， 顶多是代码实现的方式不一样

而不同的鸭子， 有不同的叫的方式， 也有不同的飞的方式。
在策略模式中， 我们把 叫 和 飞 都抽象成具体的行为模式， 子类通过选择不同的行为模式， 而具备不同的功能。在这里， 行为已经不是类的一个方法， 而是一个属性变量。 这样就把方法和属性是同等看待了。基类包含 所有子类都具备的属性和方法， 这些都是抽象的，在实例化时抽象的东西变得具体。 
在实例化时， 传入不同的参数到构造函数中， 具体的实例对象拥有了不同的属性。比如 一只时速 100km/h 的鸭子， 和 一只 1m/h的鸭子。
同理， 在实例化时，可以传入不同的行为方法对象， 具体的实例对象就拥有了不同的行为模式， 比如一只 哇哇叫的鸭子， 和一只 嘎嘎叫的鸭子。 

在策略模式中， 属性和行为模式都是 一个类的变量。 像上面的说的  速度和 叫 方法对象。 


7. Only talk to your friends.
    

6. 好莱坞原则： 
    让父类决定 何时调用和如何调用， 子类只是提供方法的实现， 而不调用已在父类实现的方法。

    在模板方法模式中， 抽象出来的公共操作骨架 在父类中， 由父类决定如何调用。 钩子函数决定何时调用。 

    子类只是覆盖了必要的抽象方法。 

    和依赖倒置的区别
        依赖倒置指明 不要声明 具体某个子类的成员对象， 声明类型应该为其父类。 再根据动态地改变引用去获得不同的实例对象。

        好莱坞原则规定 对于公共的操作， 子类不要试图实现这个操作或是指明实现方法， 把操作的实现抽象到父类， 子类只是提供各个步骤的实现而已。 各个步骤的方法的调用都在父类声明。 



