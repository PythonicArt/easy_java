状态机的实现
    状态机由 动作和状态组成。

方案一；
    用编号表示状态，使用函数对应动作， 动作内部根据当前状态判断进入一个新的状态。

    劣势；
        1. 由于采取某个动作时， 系统可能处于任何状态， 这样就会在每一个函数中产生巨量的条件判断语句。 
        2. 如果新加或删除状态， 每个函数都要改。 已有代码修改太多。
        3. 状态的转换不清晰， 要深入到每个函数内部检查每个if语句， 整理查看， 一点也不直观。
        4. 没有任何封装。

方案二；
    状态机模式
        The State Pattern allows an object to alter its behavior when its internal state changes. The object will appear to change its class.

        要素
            1. 讲不同的状态用独立的类表示， 也就是 每个类负责一个状态。
            2. 系统使用一个成员变量 curState 引用一个状态， 表示当前的状态。 当状态切换， 这个变量就引用其他对象。
            3. 不同的类实现同一个接口, 每个接口函数对应一个动作， 即接口定义了该系统能够处理的所有动作， 每个状态类实现就是都能响应。
            由于curState对应某个时刻的状态， 这样就不用再判断当前的状态， 从而消灭了if语句。 
            4. 状态转换的实现
                1. 每个状态也引用其 状态机对象， 在每个动作函数的内部， 修改状态机对象的状态。（这样有个缺点是 不同的状态存在依赖关系， 状态转换时， 需要知道下一个状态对象。 可以通过get方法获取而不是直接取状态机的某个状态对象）
                2. 每个状态不知晓状态机， 状态机根据动作函数的返回值 决定 状态机的下一步状态。

        优势
            方案一的劣势全无
            1. 不需要维护if语句
            2. 新加或删除状态， 只需新建和删除类即可
            3. 查看全局的状态转换时, 查看对应函数里的的setState即可 


一些思考
    1. 多个状态机的实例, 如何共享状态对象？
        多个状态机实例中， 状态对象的动作函数中， 不能有状态转换。状态的改变必须串行化。 否则， 只能单例化状态机。
        利用static的 类共有的语言特性， 将每个state类共享。
    
    2. 和策略模式的区别
        两者在形式上是一样的， 通过组合的方式 绑定一个接口实例。 

        策略模式通过不同的子类绑定不同的实例而得到 表现该子类的行为

        状态机模式 状态机新建一系列接口实例， 也就是状态实例， 通过动态的绑定不同的状态实例， 表现状态机的不同状态。

        区别是 状态机模式自己管理这些状态实例， 而策略模式由client分配
