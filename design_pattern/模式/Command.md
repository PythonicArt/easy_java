命令模式-- 对实现请求的封装。

Encapsulates a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.

把请求的响应 封装成一个对象， 该对象在语义上执行某种操作， 外界通过语义(对象的名称)知道它是干什么的， 但是不知道它是怎么干的。

比如 有一个制作冰激凌的机器， 语义上知道它可以提供一份冰激凌， 但是不知道也不需要它是怎么做到的。


适用场景
    一个对象请求一个自己无法实现的功能。 这个可以是调用其他对象的函数， 也可以是向服务器发起某个请求。

    当一个系统需要提供这些多种不同的功能时


实现方案1：
    直接调用方法。 比如老板想吃冰激凌， 他选择自己做一个出来。

    缺陷非常明显， 增加了调用方的负担， 吃冰激凌前要先学会做冰激凌， 太累而且可能还不好吃。 


实现方案2： 命令模式。
    
    要做一个事情， 不需要自己做， 去找专业人士帮我解决。

    设置一个人才市场， 每一个摊位都有一个专业代理人，专业代理人不是自己解决问题， 而是认识专业人士而已。 这样， 每一个问题都能找到一个专业代理人帮我解决。

    制定一套和这些专业人士沟通的方法(暗号)， 通知他们我需要解决问题。

    比如， 想吃冰激凌， 这一次我学聪明了， 我去人才市场找到一个冰激凌代理人， 我通过暗号告诉他解决我的问题， 他打电话给专业做冰激凌的人，麻溜溜地就做好了， 然后把冰激凌送到了我手上。 此时， 我根本不用花心思去考虑怎么去做冰激凌， 也不需要认识会做冰激凌的人， 只需要学会那套暗号去人才市场勾搭就好了。 

    优势
        专业术语是解耦。 减少和其他对象、操作的相关性。 其他对象或操作的修改 尽可能少地影响当前对象。
        上面的例子， 如果是自己去 做冰激凌， 如果做冰激凌的方式调整了， 那么我这个做冰激凌的人的代码也要改。耦合程度非常大。


代码的实现

    Client  请求方， 需要服务的一方,  就是那个想吃冰激凌的人。

    Invoker 人才市场的管理员， 人才市场有很多摊位， 他们决定哪个摊位放置哪一个专业代理人 Command 对象。
            摊位的实现可以选择不同的数据结构，数据类型是 Command接口。

    Command  专业代理人， 他们认识能解决具体问题的专业人士， 用一个成员变量引用Receiver对象。 暗号系统是和他们沟通的方式， 是接口开放公共的方法。 抽象出一个接口，由具体的子类实现。
        public interface Command{
            public void execute();
            public void undo();
        }

    Receiver 请求的真正执行方， 请求的接收者。 提供解决问题的方法。


    undo 方法的实现。
        属于暗号系统里的另一种暗号， 这个暗号牛逼了。 如果你觉得之前的暗号说错了， 发个后悔暗号。 代理人就知道要改回来了。

        其实就是一个特殊的方法， 让某个系统 恢复到  执行 execute前的状态， 也可以理解成和 execute 对立的状态。
        比如 灯的开关。 比如， 我想吃冰激凌，代理人给了我一个， 但是我7天无理由退款， 代理人就找专业人士 undo就可以了。 


一些思考
    1.  一定是代理人+专业人士这样的组合吗， 如果代理人自己就很牛逼， 把问题解决了呢？
        这是可以的， 从client的角度， 不需要知道具体是怎么做的。 但是这本身不够灵活， 这一套系统灵活之处在于 代理人可以随时修改他人士的专业人士。如果代理人自己做， 代码已经编译好， 不支持动态修改了。

    2. 如何实现多步骤undo呢, 即恢复多次？
        维护一个栈， 每当一个代理人execute之后， 把他们的名字入栈。 每回退一步， 栈顶元素出栈即可。


命令模式的两个实际应用

1. 消息队列
    
    服务提供商 开放了一个 大型人才市场， 供client请求服务。

    每次请求， 都会找到一个Command对象， 执行动作并且返回。 如果是同步的方式， Client需要卡住， 等待动作执行完毕。

    同时， 如果一时间有大量的 client 来请求， 需要按先后地处理请求， 而且资源摊位有限， 如果不加约束， 人山人海， 会挤爆人才市场。

    消息队列很好地解决了上述问题。 
        根据先后把Command对象进入队列， 处理者 从队头依次获取Command执行， 保证先后次序。
        队列设置容量， 避免挤爆的情况发生。

        可以让多个线程共同来处理消息队列的消息， 增加系统的吞吐量。

2. 系统恢复， 事务的一种实现方式。
    执行一系列操作， 假如系统在中间崩溃， 则崩溃前的操作都需要清除掉， 系统恢复到执行操作以前的状态。

    实现方式1：
        开始一段事务前， 把系统的所有数据都备份， 如果出现问题， 则用备份数据覆盖当前数据。
        缺陷：
            备份所有数据， 对于大数据系统来说不现实。 
            而且一段事务造成的数据变化只是局部的， 备份全部也是无意义的。

        但这个方法足够简单和直接， 在开销允许的情况下优先选择。

    实现方式2：
        用命令模式。方法和 多步骤的undo是一样的,  维护一个栈，每次执行一次execute就把Command对象记下来。 当系统出错， 就用这个栈来恢复。 



