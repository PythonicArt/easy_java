披萨店供应多种多样的披萨问题。 --- 生成对象的封装

点披萨的一系列过程， orderPizza()：
    获得一份披萨配方， pizza
    pizza.准备原料
    pizza.烘焙
    pizza.切块
    pizza.包装
    retrun pizza


需求是 披萨配方有很多种，而且， 不同的披萨会有不同的选材方案。 如何实现？

一个对象(Creater)的引用另一个类(Component)的实例， 但是不同的情况或者条件下， 引用的实例是变化的。
        
Creater 声明一个 Component 对象， 而具体引用的类型是 Component 的某个子类。借助多态的性质， 实现统一操作。
Component 自身是抽象的， 无法实例化。

方案1：
    披萨配方+原料选材方案 可以唯一确定一种披萨，为每一种披萨写一个方法。
    各个方法中独立地获取配方和准备原料， 并制作。

    缺陷：
        没有代码重用， 公共部分也没有进行抽象。 
        方法的数量和披萨的种类数相同，而披萨种类千变万化 无法穷尽。 


方案二：
    将配方类型+ 选材方案作为参数传入 orderPizza, 在方法内根据类型选择具体的配方和选材方案。

    orderPizza(Type, IngredientType){
        if(Type == xxxx){
            if(IngredientType == xxxxx)
        }
        ...

        烘焙
        切块
        包装
        上菜
    }

    缺陷：
        这里多重的if语句使代码冗长， 不够清晰而且难以维护. 其实和方案一无区别， 只是将方案的选择统一到了一起。 
        可以看到， 变化的部分只是选择配方类型和原材料， 加工过程是统一不变的。


方案三：简单工厂模式
    把变化的部分 (这里是选择的逻辑) 从方法中抽离出来, 制作一个选择方案的接口. 这样当前方法就不用变化了， 当需要调整， 只需要改变接口里面的内容。 
    
    这个接口就是工厂方法。 形象地比喻， 我需要一个披萨， 我联系了一个生产披萨的厂家， 我需要的时候把类型告诉它， 它就可以给我了。 而具体它是怎么弄出来的(new 一个实例)， 我不知道也不需要知道。 因为在我这里流程是不变的。我只需要获得这个披萨， 并用它来做其他事情。

    实现方案：

        新建一个 工厂Factory(接口或是抽象类)， 工厂 开放一个 根据配方方案 返回 Component 的具体子类实例的方法。
        用 Factory子类 去和 Component 子类建立联系， 也就是一种工厂返回确定的 Component.
        
        Creater 引用一个Factory 实例， 在需要披萨的时候通过这个实例创建。

        不足之处：
            Clinet在使用时, 每次都要自己去考虑 把 Creater 和 Facotry绑定， 有点繁琐。

方案四：
    把Creater 抽象出来， 让具体的Creater继承。 具体的子类已经绑定具体的Factory， 子类重载creater方法。
    Client在使用时， 选择具体的Creater 子类即可。 

    也就是说， 一个creater 与一个Factory绑定在一起， 为client提供所有需要的 Component。

    优势：
        实体部分得到封装，创造实体的部分得到封装。这一部分和Creater脱离， 可以代码复用。

        User只是依赖 creater方法这个接口， 而不是一个具体的子类(如果用new的方式， 就是依赖具体的类)

        依赖接口使得 User部分地代码无需修改。 需要修改调整接口（即子类的实现）即可。

        User 与  Component 的联系是松耦合的。 User不是直接 new Component， 而是通过工厂方法获得一个 Component实例。


工厂方法-creater
    把创建一个实例的方法抽象， 由子类继承并实现。 

        
工厂模式-
    User多个引用的对象有组合关系， 工厂将组合进行封装。
    User在该组合下的引用对象， 都统一由这个工厂提供。

    其实就是一个抽象接口 包含了多个工厂方法， 给一个User提供多个Component实例， 只是这些Component是一套整体的搭配方案.



