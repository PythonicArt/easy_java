咖啡/饮料搭配的问题。 --- 功能拓展的实现

需要动态的生成不同搭配调料的 饮料, 并计算价格。

方案一：
暴力穷举 各种可能出现的搭配, 为每一个搭配声明一个类。 

缺陷：无法穷举。 一旦出现增加或移除某种饮料，修改的工作量也会很大。

方案二：

饮料为一个类， 搭配作为饮料的属性。 一种搭配就是一种属性。
抽象出一个基类， 基类计算所有调料的价格。 通过判断存在某种调料而加上该种调料的价格。

而具体的某种饮料继承该基类，通过修改属性决定是否拥有某种调料。 

计算价格时, 通过调用父类的价格方法获得自己调料的价格 加上自身的价格 获得总价格。

缺陷：
    调料做为对象的属性的存在, 需要提前确定并写到类中。 每一种调料的价格也这样。

    这样无法动态地增删调料的类型， 和修改调料的价格。

    同时， 基类计算价格时， 需要对所有调料类型进行判断。而有些属性， 对于子类来说根本就不存在。


方案三： 装饰器模式
    动态的为一个类的某个方法 增加功能(responsibilities)

    对于一个方法 fun(), 通过装饰变为 
    Fun(){
        do_xxxx();
        fun();
        do_xxxx();
    }
    fun() 内部的实现是不修改的。

    被装饰的基类为 Component

    装饰类称为 Decorator, 该类也继承自 Component, 但同时拥有一个Component 的实例变量 oComponent， 这个实例就是自己装饰的对象

    所以, Decorator 自己也具有 fun 方法， 通过重载的方式升级了方法。
    fun(){
        do_xxxx();
        fun();
        do_xxxx();
    }

    装饰是可以链式的， 包装的层次可以随意叠加。

    Decorator d = new Decorator(oComponent);

    d 本身也是一个Component ， 也可以被其他装饰器装饰。

    区分什么是基础的 Component , 什么是 Decorator
    Decorator 多了一个实例变量， 指向其装饰的 Component

    逻辑上， 可以多种同时出现的作为 Decorator， 只能单独出现的是 Component.
    像饮料问题， 调料是Decorator, 咖啡品种 是 Component

    多态在装饰器模式上的应用
        不管是 Decorator 还是 ConcreteComponent 都继承于 Component,
        声明一个基类的对象， 通过多态， 这个对象可以引用任何 子类对象 

设计原则
    类应该开放拓展，而拒绝修改。


用装饰器模式 理解 JAVA I/O
    BufferedInputStream 是对 FileInputStream 的 装饰， 就是对其功能的拓展


装饰模式的一些问题：
    每一次装饰， 就像一次进化， 在原有的功能基础上新增其他的操作。 但是当装饰层级变多， 会很难查清楚这究竟包装了多少层， 具体具有怎样的操作。

    如果把包装用类封装， 则每一个装饰器就是一个类， 使用者需要弄清楚这些类的区别和具体用法。 往往这些类之间都只是有一些细节的差异。
    











