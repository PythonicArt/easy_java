不同类型的鸭子带来的思考--- 行为的封装

当部分子类需要新增一个方法，而而其他子类不需要该方法时的处理方式。

1. 在父类中新增该方法， 留空。 子类中具体实现。 不需要该方法的子类无需修改。
缺陷： 如果实现方式由n个版本，则只有一种子类实现了代码复用， 其他种类的子类需要重写重复代码。

2. 使用接口。需要该方法的实现该接口， 不需要的则不实现。
缺陷： 完全没有代码复用。而且增加了实现接口的工作量。 比1还要糟糕。

3. 归类。
经过分析， 某个操作有n个不同的表现形式， 则需要为该方法新建一层子类， 该层子类供其他子类继承。
该方法看似解决代码复用的问题， 但是仍然有以下问题
1. 一旦继承了某个类， 就意味着固定了某种实现。 不能支持运行时的改变。如果一个实例执行A版本的操作之后又需要执行B版本的操作， 这样无法实现。只能新建一个能够实现B版本的实例， 让它来操作。
2. 无法清晰全面的了解所有子类的行为。 因为父类没有声明该方法， 该方法是由新建的一层子类添加的。从而， 也就无法在父类的层级上实现多态。
3. 修改操作的实现， 会影响到所有当前类的实例。 这是继承的特点，但这在这里成为了缺点。


4. 使用 strategy pattern

对于上述千变万化的操作， 不再使用成员方法来实现， 一旦使用成员方法， 就不可避免的有继承的问题。
使用成员对象， 该对象实现了这个操作。 这个成员对象实现一个统一的接口， 具有某个相同的方法。

在父类中统一一个该操作的接口， 接口中使用成员对象去调用其实现的方法。
在父类中统一一个 设置该成员对象的接口， 当需要其他版本的对象时可以修改。

所有的子类都继承父类， 由于继承，子类都具有实现该方法的成员对象， 和操作接口， 设置该成员对象的接口。
在具体的业务中， 子类实例调用统一的接口方法来执行该操作。

优势
0. 清晰地封装某个不同的实现， 而且不在类中实现。
1. 减少了继承的层级关系，只有一层。 观察父类就可以知道该类及其子类会做什么。
2. 支持动态的修改操作。 使用设置接口设置一个新版本的对象即可。

在策略模式中， 我们把 叫 和 飞 都抽象成具体的行为模式， 子类通过选择不同的行为模式， 而具备不同的功能。行为已经不是类的一个方法， 而是一个属性变量。 这样就把方法和属性是同等看待了。基类包含 所有子类都具备的属性和方法， 这些都是抽象的，在实例化时抽象的东西变得具体。 
在实例化时， 传入不同的参数到构造函数中， 具体的实例对象拥有了不同的属性。比如 一只时速 100km/h 的鸭子， 和 一只 1m/h的鸭子。
同理， 在实例化时，可以传入不同的行为方法对象， 具体的实例对象就拥有了不同的行为模式， 比如一只 哇哇叫的鸭子， 和一只 嘎嘎叫的鸭子。 

在策略模式中， 属性和行为模式都是 一个类的变量。 像上面的说的  速度和 叫