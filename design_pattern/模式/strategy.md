不同类型的鸭子带来的思考

当部分子类需要新增一个方法，而而其他子类不需要该方法时的处理方式。

1. 在父类中新增该方法， 留空。 子类中具体实现。 不需要该方法的子类无需修改。
缺陷： 如果实现方式由n个版本，则只有一种子类实现了代码复用， 其他种类的子类需要重写重复代码。
2. 使用接口。需要该方法的实现该接口， 不需要的则不实现。
缺陷： 完全没有代码复用。而且增加了实现接口的工作量。 比1还要糟糕。

3. 归类。
经过分析， 某个操作有n个不同的表现形式， 则需要为该方法新建一层子类， 该层子类供其他子类继承。
该方法看似解决代码复用的问题， 但是仍然有以下问题
1. 一旦继承了某个类， 就意味着固定了某种实现。 不能支持运行时的改变。如果一个实例执行A版本的操作之后又需要执行B版本的操作， 这样无法实现。只能新建一个能够实现B版本的实例， 让它来操作。
2. 无法清晰全面的了解所有子类的行为。 因为父类没有声明该方法， 该方法是由新建的一层子类添加的。从而， 也就无法在父类的层级上实现多态。
3. 修改操作的实现， 会影响到所有当前类的实例。 这是继承的特点，但这在这里成为了缺点。


4. 使用 strategy pattern

对于上述千变万化的操作， 不再使用成员方法来实现， 一旦使用成员方法， 就不可避免的有继承的问题。
使用成员对象， 该对象实现了这个操作。 这个成员对象实现一个统一的接口， 具有某个相同的方法。

在父类中统一一个该操作的接口， 接口中使用成员对象去调用其实现的方法。
在父类中统一一个 设置该成员对象的接口， 当需要其他版本的对象时可以修改。

所有的子类都继承父类， 由于继承，子类都具有实现该方法的成员对象， 和操作接口， 设置该成员对象的接口。
在具体的业务中， 子类实例调用统一的接口方法来执行该操作。

优势
0. 清晰地封装不同的实现， 而且和类没有关系。
1. 减少了继承的层级关系，只有一层。 观察父类就可以知道该类及其子类会做什么。
2. 支持动态的修改操作。 使用设置接口设置一个新版本的对象即可。