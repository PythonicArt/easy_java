问题描述：
    泡咖啡的步骤
        烧水，加咖啡，倒入杯中， 增加调料

    抛查的步骤
        烧水， 加茶， 倒入杯中， 增加调料

方案一：
    看到一些公共操作， 抽象出泡饮料的公共操作， 分别由茶 和咖啡类继承。 
    两个子类各自实现这一方法， 没有关联。 

    劣势：
        1. 无代码重用。 一些不变的操作比如 烧水， 倒入杯中。 没有抽出。 
        2. 如果新加一个饮料对象， 需要继续重复实现重复操作。 
        3. 对公共操作没有一个全局的认识， 因为各个子类独自实现。 需要去具体的子类中研究其大致的实现方式。 

方案二： 模板方法模式
    抽象出公共操作， 在父类中实现该方法， 操作中不变的方法也由父类实现。 而根据子类进行变化的方法，则声明为抽象方法， 需要由子类实现。

    子类不再覆盖公共操作方法， 而是覆盖操作中某个步骤方法。 

    可以用 final 声明父类中的公共操作方法， 禁止子类覆盖。 

    优势
        方案一的劣势全无。

        这是一个很常见的模式， 类似 给出一份操作说明， 每个步骤执行什么和执行顺序是怎样的。 

        而具体的实现由子类给出。 父类是框架， 子类注入灵魂。 


定义
The Template Method Pattern defines the skeleton of an algorithm in a method, deferring some steps to subclasses.
Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.

一个操作有多个步骤， 其中部分步骤是不断变化的， 会存在多个版本。 一个简单的实现就是 将这个操作和不变的步骤方法抽象出来存在父类中。 
由子类继承父类， 实现变化的步骤方法。  

适用范围：
    一个统一的操作，不同的对象， 只是在这个操作中个别步骤不同。


钩子函数
    上述公共操作中 调用的非抽象方法 就是一个钩子。 这个钩子在父类中可能没有具体的意义和操作， 由子类的覆盖来赋予其操作。

    钩子的一个作用是可根据外部的状态决定 操作中 某个方法是否被调用。
    if(hook()){
        do_some_thing();
    }

    这里的hook可以根据client的状态返回 true或false

    当公共操作中 某个方法是必须被调用的，使用子类覆盖抽象方法的方式。
    当某个方法选择性地调用时， 使用hook控制。



一些使用案例：
    1. 支持任何对象列表排序的模板方法。 
        抽象出比较两个对象的方法
            R = (Comparable)a.compareTo((Comparable)b)  判断 a 与 b 的关系. 

            具体如何比较， 则交给 子类， 即覆盖 compareTo方法。 

    2. JFrame 与 Applets 等窗体类。
        显示逻辑交给父类， 子类只需提供 元素和覆盖 paint等方法


和 Strategy 的区别
    Template 提供了一个 操作的框架， 由子类覆盖其中的步骤。 一定是有些操作是相同的， 而有些操作需要自定义

    Strategy 指明操作， 但是不做实现， 只是说明有这个操作。 而具体的实现是通过其成员对象引用的实例做到的。 









