
面向对象的根本目的是实现代码复用



对象的分类
    基本数据
    对象

    不同对象作为函数参数的区别
        简单类型是按值传递, 对象是按引用传递。

对象的使用

对象声明-类声明
    构造函数， 析构函数

    成员隐藏
        public
        private
            只能在声明内被类成员引用, 而不能被实例化的对象引用
            子类的声明中， 如果一个数据成员继承自父类， 并且是private的， 子类声明是不能直接引用该成员的
        protected

    静态数据
        如果一个成员被static修饰， 则它能在任何对象呗实例化前访问。并且只能通过类名访问， 而不能通过任何实例化的对象以及  this, super访问。

        变量
            该变量是全局的， 由于不能被任何一个实例引用，它是属于类的。 Class.Name获得一个唯一地址，取得数据

        方法
            方法内只能 引用 同类的静态成员

    this

对象实例化
    对象的声明 只是 说明了 一个类有那些成员和其访问权限等。 实例化是指在运行时， 在内存中生成一个对象实体。
    就好像在世界上创造了一个 具体的对象。 

继承
    一个类只能有一个父类, 而c++ 允许有多个父类。

    使子类具有和父类相同的声明，即相同的数据成员和方法。 这里是复制, 不是共用的意思。
    但只是 大致复制, 具体会根据访问权限修改。
    优点： 增加代码的重用， 而无需重新复制。 有些类就是其他类的扩展，非常适合这样的情况

    关于访问权限的继承
        在父类中为 private的成员， 子类成员没有权限访问。 也就是说， 子类不能直接引用该成员， 而只能通过可访问的父类方法来引用该成员， 如果父类没有开放， 则子类啥也做不了。即使自己有这个成员

    对象实例的 upcasting 与 downcasting
        downcasting:
            实例变量 a 是一个父类对象的实例, 它可以改变指向, 引用到一个子类对象
            这里 a虽然看起来是升级了, 但是它只能访问 父类 定义的那一部分
            因为a在首次声明的时候就已经确定其引用类型

            有趣的是, 如果父类定义的那一部分被子类 **重载** 了, 则访问的是被重载的内容
            
            这样就实现了多态

            声明一个父类变量， 但是引用到不同子类的对象去， 这样调用父类的一个接口，执行的确实子类实现的具体版本

            动态绑定机制
                因为多态的存在, 对于一个调用的发生, 编译阶段是不能确定其具体的函数执行逻辑的。
                只有在真正执行的那一刻才能决定. 这在一定程度上带来了程序的开销, 但是完全值得的

        upcasting:
            实例变量 a 是一个子类对象的实例， 它可以改变指向, 引用到它父类的对象。
            这里也不能访问子类所拓展的成员， 因为引用的那个父类对象，根本就没有这些。

    子类声明一个和父类相同的成员
        子类的所有声明都是对父类的拓展, 如果出现同名情况, 则子类会包含两份数据

    super
        访问父类的构造函数, 必须是子类构造函数中的第一个执行语句, 而且在多层次的继承中， 访问的是直接父类的构造函数
            super(a, b, c);

        访问子类与父类同名, 而且是父类部分的成员

    构造函数的执行顺序
        子类的构造函数执行的第一条语句就是执行父类的构造函数,如果指定了super，就调用对应的父类构造函数， 如果没有， 则调用默认的无参数构造函数

        子类是父类的拓展, 子类是依赖父类的。 子类的实例化时，会先将继承自父类的部分初始化， 即调用父类的构造方法

    抽象类
        抽象类是多态的一种抽象

        至少存在一个抽象方法， 该方法没有实现的细节。
        抽象类无法实例化, 即无法使用new在内存空间中生成实例

        子类如果需要实例化，就必须实现(重载)所有父类声明中的抽象方法。 否则， 子类仍然是抽象类

        通过一个父类变量去引用不同实例的同名实例方法, 运行时根据引用的实际对象决定方法的不同版本

对象的生存周期

垃圾回收


接口
    接口的作用 
        具有多重继承的功能
        对于继承的方式， 当继承层级很多， 位于底层的子类会拥有很多自身并不需要的方法或是成员， 他们来自中间层级的多个父类。这样实例化一个对象，就会占用很大的内存空间（待商榷）.

        接口是一个系列方法的集合， 一个类可以按照自己的需要去实现特定的接口， 从而拥有方法集合。
        这是组合的方式， 比继承关系更加灵活。

    接口同抽象类，方法都是抽象的， 只提供方法声明， 而不给出实现。 由实现该接口的子类来给出具体的实现方式。

    如果一个类， 并没有完全实现某个接口的方法， 其应该被声明为abstract的。 当做抽象类。

    接口一般用public修饰， 其方法和变量也都是public的

    接口的继承。
        同类的继承一样， 一个接口可以在另外一个接口的基础上进行扩展。 用 extends . 这也只能是单一继承。

    接口实例对象
        可以声明一个接口对象， 但是只能引用到实现该接口的可以实例化的类对象上。
        通过引用到不同的类， 调用同一个接口中的方法， 实现多态。
        
        该接口对象， 只能访问接口中定义的方法， 而实现类中接口以外的方法是不可见的。
        这在继承中也是一样的， 一个父类的对象， 如果引用到了子类上， 只能访问父类所有的并且可访问(访问控制符控制)的对象


