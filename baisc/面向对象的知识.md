对象的分类
    基本数据
    对象

    不同对象作为函数参数的区别
        简单类型是按值传递, 对象是按引用传递。

对象的使用

对象声明
    构造函数， 析构函数
    成员隐藏
        public
        private
            只能在声明内被类成员引用, 而不能被实例化的对象引用
            子类的声明中， 如果一个数据成员继承自父类， 并且是private的， 子类声明是不能直接引用该成员的
        protected

    静态数据
        如果一个成员被static修饰， 则它能在任何对象呗实例化前访问。并且只能通过类名访问， 而不能通过任何实例化的对象以及  this, super访问。

        变量
            该变量是全局的， 由于不能被任何一个实例引用，它是属于类的。 Class.Name获得一个唯一地址，取得数据

        方法
            方法内只能 引用 同类的静态成员

    this

对象实例化

继承
    一个类只能有一个父类, 而c++ 允许有多个父类。

    使子类具有和父类相同的声明，即相同的数据成员和方法。 这里是复制, 不是共用的意思。
    但只是 大致复制, 具体会根据访问权限修改。
    优点： 增加代码的重用， 而无需重新复制。 有些类就是其他类的扩展，非常适合这样的情况

    关于访问权限的继承
        在父类中为 private的成员， 子类成员没有权限访问。 也就是说， 子类不能直接引用该成员， 而只能通过可访问的父类方法来引用该成员， 如果父类没有开放， 则子类啥也做不了。即使自己有这个成员

    对象实例的 upcasting 与 downcasting
        downcasting:
            实例变量 a 是一个父类对象的实例, 它可以改变指向, 引用到一个子类对象
            这里 a虽然看起来是升级了, 但是它只能访问 父类 定义的那一部分
            因为a在首次声明的时候就已经确定其引用类型

            有趣的是, 如果父类定义的那一部分被子类 **重载** 了, 则访问的是被重载的内容
            这样就实现了多态

            声明一个父类变量， 但是引用到不同子类的对象去， 这样调用父类的一个接口，执行的确实子类实现的具体版本

            动态绑定机制
                因为多态的存在, 对于一个调用的发生, 编译阶段是不能确定其具体的函数执行逻辑的。
                只有在真正执行的那一刻才能决定. 这在一定程度上带来了程序的开销, 但是完全值得的

        upcasting:
            实例变量 a 是一个子类对象的实例， 它可以改变指向, 引用到它父类的对象

    子类声明一个和父类相同的成员
        子类的所有声明都是对父类的拓展, 如果出现同名情况, 则子类会包含两份数据

    super
        访问父类的构造函数, 必须是子类构造函数中的第一个执行语句, 而且在多层次的继承中， 访问的是直接父类的构造函数
            super(a, b, c);

        访问子类与父类同名, 而且是父类部分的成员

    构造函数的执行顺序
        子类的构造函数执行的第一条语句就是执行父类的构造函数,如果指定了super，就调用对应的父类构造函数， 如果没有， 则调用默认的无参数构造函数

        子类是父类的拓展, 子类是依赖父类的。 子类的实例化时，会先将继承自父类的部分初始化， 即调用父类的构造方法

    抽象类
        抽象类是多态的一种抽象

        至少存在一个抽象方法， 该方法没有实现的细节。
        抽象类无法实例化, 即无法使用new在内存空间中生成实例

        子类如果需要实例化，就必须实现(重载)所有父类声明中的抽象方法。 否则， 子类仍然是抽象类

        通过一个父类变量去引用不同实例的同名实例方法, 运行时根据引用的实际对象决定方法的不同版本

对象的生存周期

垃圾回收
